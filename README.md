# 📱 오픈티콘

| 항목          | 내용 |
|--------------|------|
| 🕒 기간      | 2024-10 ~ 2024-11 |
| 👥 인원      | 6명 |
| 🛠 사용 기술 | <img src="https://img.shields.io/badge/kotlin-%237F52FF.svg?style=for-the-badge&logo=kotlin&logoColor=white" alt="Kotlin"/> <img src="https://img.shields.io/badge/Android-3DDC84?style=for-the-badge&logo=android&logoColor=white" alt="Android"/> <img src="https://img.shields.io/badge/java-%23ED8B00.svg?style=for-the-badge&logo=openjdk&logoColor=white" alt="Java"/> <img src="https://img.shields.io/badge/spring-%236DB33F.svg?style=for-the-badge&logo=spring&logoColor=white" alt="Spring"/> <img src="https://img.shields.io/badge/express.js-%23404d59.svg?style=for-the-badge&logo=express&logoColor=%2361DAFB" alt="Express.js"/> <img src="https://img.shields.io/badge/postgres-%23316192.svg?style=for-the-badge&logo=postgresql&logoColor=white" alt="Postgres"/> |
| 🎯 담당 역할 | 1) 이모티콘 검색 기능 개발 (안드로이드)<br/>2) 이모티콘 팩 상세 화면 개발 (안드로이드)<br/>3) 이모티콘 구매 및 다운로드 기능 개발 (안드로이드) |
| 📖 개요      | 자유로운 이모티콘 공유 및 사용 플랫폼 (안드로이드 모바일 앱, 웹) |

# 💡 프로젝트 개요
## 배경 및 목표
- 오픈티콘은 사용자가 직접 제작한 이모티콘을 자유롭게 등록하고, 다양한 플랫폼에서 손쉽게 사용할 수 있도록 돕는 서비스입니다.
- 이모티콘 시장의 빠른 성장과 사용자들의 다양한 니즈를 반영하여, 누구나 쉽게 이모티콘 작가로 데뷔하고, 이모티콘을 다양한 용도로 활용할 수 있는 환경을 제공하는것을 목표로 합니다.

## 주요 기능
### ✅ 이모티콘 스토어 (모바일)
| 이모티콘 스토어 메인 | 이모티콘 팩 상세 화면 | 이모티콘 검색 |
| --- | --- | --- |
| ![image](https://github.com/user-attachments/assets/f4b4d318-162a-4504-b086-3219fc69c612) | ![image](https://github.com/user-attachments/assets/8e9efa4d-30cd-429c-8750-095ddb9a4732) | ![image](https://github.com/user-attachments/assets/4786fde2-9289-4f09-9c32-9e80baf0715b) |

- 이모티콘 스토어에서 신규, 인기, 태그별 이모티콘을 탐색할 수 있습니다.
- 이모티콘 팩 상세 화면에서는 이모티콘 미리보기를 제공하며 구매 및 다운로드를 할 수 있습니다.
- 이모티콘 검색 화면에서 텍스트로 이모티콘을 검색할 수 있습니다.

| 플로팅 아이콘 클릭시 | 이모티콘 클릭시 | 붙여넣기로 전송 |
| --- | --- | --- |
| ![image](https://github.com/user-attachments/assets/d39fcdfa-b2bc-46fe-9bbc-baf43611ceb0) | ![image](https://github.com/user-attachments/assets/6f599732-b800-4503-9f53-659c4a144042) | ![image](https://github.com/user-attachments/assets/c4a0ce86-b7c9-4ec1-8523-d9260bd7ad62) |

- 스토어 앱에서 "이모티콘 서랍" 버튼으로 플로팅 아이콘을 켜고 끌 수 있습니다.
- 플로팅 아이콘을 통해 다른 앱 위에서 사용할 수 있습니다.
- 플로팅 아이콘을 클릭하면 내가 다운로드한 이모티콘들이 플로팅 윈도우로 표시됩니다.
- 원하는 이모티콘을 클릭하면 클립보드에 이미지가 복사됩니다.
- 이미지 붙여넣기를 지원하는 어떤 곳이든 (카카오톡, 디스코드, Mattermost 등) 붙여넣기로 편리하게 전송할 수 있습니다.

| 이미지로 이모티콘 검색 | 소셜 로그인 | 구매한 이모티콘 관리 |
| --- | --- | --- |
| ![image](https://github.com/user-attachments/assets/3886fefe-1993-4626-99a7-73ae147ee903) | ![image](https://github.com/user-attachments/assets/850ef654-0424-4ab2-92bd-7d5b7020bf5d) | ![image](https://github.com/user-attachments/assets/e717488c-14a1-406e-806b-ad7763a556dc) |

- 텍스트 뿐만 아니라 이미지로도 유사한 이모티콘을 검색할 수 있습니다.
- 소셜 로그인을 지원합니다.
- 내 이모티콘 관리에서 순서 및 표시 여부를 편집할 수 있습니다.


### ✅ 이모티콘 스토어 (웹)
- 웹 이모티콘 스토어는 주로 이모티콘 작가를 위한 서비스 입니다.

![image](https://github.com/user-attachments/assets/bc953d63-912c-4ef0-a1b6-dd95af7789da)

- 작가는 자신이 만든 이모티콘(이미지)을 팩으로 업로드할 수 있습니다.

![image](https://github.com/user-attachments/assets/00c42236-9285-49c7-a1e8-4f51b0b0c605)

- AI 기능을 이용해 이모티콘을 제작하는 이모티콘 스튜디오를 제공합니다.

![image](https://github.com/user-attachments/assets/e79ed8c3-7f59-467b-8bf6-b1d116b27579)

- 웹에서도 이모티콘을 탐색할 수 있습니다.

![image](https://github.com/user-attachments/assets/b2c15499-6037-4647-bf2b-016b018332f0)


# 🔥 나의 기여
## 1️⃣ MVVM 패턴 적용
본 프로젝트에서는 안드로이드 코드 전반에 MVVM 패턴을 적용하였습니다.

- MVVM 패턴은 다음 세 가지 주요 컴포넌트로 구성됩니다.
  - Model (모델): 데이터 및 비즈니스 로직을 담당하는 계층
  - View (뷰): UI를 담당하며 사용자의 입력을 처리하는 계층
  - ViewModel (뷰모델): Model과 View 사이에서 데이터를 관리하고 UI 로직을 처리하는 계층
- MVVM 패턴의 장점은 다음과 같습니다.
  - **UI와 비즈니스 로직 분리** → ViewModel이 UI 로직을 담당하므로 UI 코드가 깔끔해짐
  - **생명 주기 관리** → ViewModel은 Activity/Fragment의 생명 주기와 무관하게 데이터를 유지
  - **비동기 처리 최적화** → Coroutine을 활용하여 백그라운드에서 데이터 로딩 가능

이모티콘 검색 화면의 예를 통해 프로젝트에서 MVVM 패턴을 적용 방식을 설명하겠습니다.

### 1. ViewModel을 이용한 UI 상태 관리

`SearchScreenViewModel`은 검색 화면에서 UI 상태를 관리하며, `StateFlow`를 이용해 Compose UI와 데이터 바인딩을 수행합니다.

#### ViewModel 코드:
```kotlin
@HiltViewModel
class SearchScreenViewModel @Inject constructor(
    private val searchEmoticonPacksUseCase: SearchEmoticonPacksUseCase,
    private val searchEmoticonPacksByImageUseCase: SearchEmoticonPacksByImageUseCase
) : ViewModel() {
    private val _searchText = MutableStateFlow("")
    private val _searchResult = MutableStateFlow(emptyList<SearchEmoticonPacksListItem>())
    private val _isLoading = MutableStateFlow(false)
    private val _selectedImageUri = MutableStateFlow<Uri?>(null)

    val searchText: StateFlow<String> = _searchText
    val searchResult: StateFlow<List<SearchEmoticonPacksListItem>> = _searchResult
    val isLoading: StateFlow<Boolean> = _isLoading
    val selectedImageUri: StateFlow<Uri?> = _selectedImageUri

    fun onSearchTextChange(value: String) {
        _searchText.value = value
    }

    fun search() {
        viewModelScope.launch {
            _isLoading.value = true
            val result = searchEmoticonPacksUseCase(_searchText.value)
            _searchResult.value = result
            _isLoading.value = false
        }
    }
}
```

#### 주요 구현:
- `MutableStateFlow`를 사용하여 UI 상태를 관리함
- `onSearchTextChange()`를 통해 사용자의 입력을 반영
- `search()` 메서드에서 비동기 작업을 수행하여 검색 결과를 가져오고 UI 상태를 업데이트
- `viewModelScope.launch {}` 블록을 사용하여 코루틴 실행 (백그라운드 작업 수행)

### 2. Compose UI에서 ViewModel과 데이터 연동

`SearchBar` Composable 함수에서는 `ViewModel`을 `hiltViewModel()`로 주입받아 UI와 상태를 연결합니다.

#### SearchBar 코드:
```kotlin
@Composable
fun SearchBar(
    viewModel: SearchScreenViewModel = hiltViewModel()
) {
    val searchText by viewModel.searchText.collectAsState()
    val context = LocalContext.current

    Row(modifier = Modifier.fillMaxWidth()) {
        BasicTextField(
            value = searchText,
            onValueChange = { viewModel.onSearchTextChange(it) },
            keyboardOptions = KeyboardOptions.Default.copy(
                imeAction = ImeAction.Search
            ),
            keyboardActions = KeyboardActions(
                onSearch = {
                    viewModel.search()
                }
            )
        )
    }
}
```

#### 주요 구현:
- `viewModel.searchText.collectAsState()`를 사용하여 UI가 ViewModel의 상태를 관찰
- 사용자가 텍스트를 입력하면 `viewModel.onSearchTextChange()`가 호출되어 상태를 업데이트
- `imeAction = ImeAction.Search`를 설정하여 엔터 키 입력 시 `viewModel.search()`가 호출되도록 구성

### 3. 비동기 네트워크 요청 처리

ViewModel 내부에서 `suspend fun`을 사용하여 네트워크 요청을 비동기적으로 처리합니다. 이는 UI 스레드를 차단하지 않고 데이터를 가져올 수 있도록 합니다.

#### 네트워크 요청 코드:
```kotlin
suspend fun loadMoreSearchResult() {
    if (_isLoading.value) return
    _isLoading.value = true

    val (newItems, isLast) = searchEmoticonPacksUseCase(
        searchKey = _searchKey.value.key,
        searchText = _searchText.value,
        page = page,
        size = pageSize,
        sort = _searchSort.value.key
    )
    _searchResult.value += newItems
    lastPageReached = isLast
    page++
    _isLoading.value = false
}
```

#### 주요 포인트:
- `suspend` 함수로 작성하여 **비동기 실행을 최적화**
- `_isLoading` 상태를 사용하여 중복 요청을 방지
- `searchEmoticonPacksUseCase()`를 호출하여 검색 API 요청 수행 후 `_searchResult` 상태 업데이트

### 결론
Jetpack Compose 기반의 MVVM 구조를 적용함으로써 **코드의 가독성과 유지보수성 향상** 및 **비동기 데이터 처리 최적화**를 달성할 수 있었습니다.

특히 StateFlow와 Hilt를 활용해 ViewModel을 구성하여 MVVM 패턴을 더욱 효과적으로 적용할 수 있었습니다.


